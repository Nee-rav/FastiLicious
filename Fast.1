import express from "express";
import OpenAI from "openai";
import Stripe from "stripe";
import dotenv from "dotenv";

dotenv.config();

/* ===================== CONFIG ===================== */

const app = express();
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

const PRICE_IDS = {
  monthly: "price_199_monthly", // Replace with actual Stripe Price IDs
  yearly: "price_1999_yearly",
};

const FREE_TRIES = 10;

/* ===================== DATA STORE (V0) ===================== */
// Note: In production, swap these for Redis/PostgreSQL
const users = new Map(); 
const stepCache = new Map();
const mistakeCache = new Map();

/* ===================== PROMPTS ===================== */

const SYSTEM_PROMPT = `You are a real-time cooking copilot.
RULES:
- Only ONE instruction at a time.
- Never reveal a full recipe. Short, direct sentences.
- Max 40 words. Max 2 sentences.
- Start with a verb. No filler.`;

const stepPrompt = (state) => `Next instruction for: ${JSON.stringify(state)}. Output format: Instruction: <text> Waiting condition: <trigger>`;

/* ===================== MIDDLEWARE ===================== */

// Critical: Stripe Webhook must come BEFORE express.json()
app.post("/webhook", express.raw({ type: "application/json" }), (req, res) => {
  const sig = req.headers["stripe-signature"];
  let event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error("Webhook signature verification failed.");
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  if (event.type === "checkout.session.completed") {
    const userId = event.data.object.metadata.userId;
    const user = users.get(userId) || { triesUsed: 0 };
    users.set(userId, { ...user, subscribed: true });
  }

  res.json({ received: true });
});

// Standard JSON parsing for all other routes
app.use(express.json());

const checkAccess = (req, res, next) => {
  const userId = req.headers["x-user-id"];
  if (!userId) return res.status(400).json({ error: "Missing user id" });
  
  const user = users.get(userId) || { triesUsed: 0, subscribed: false };
  users.set(userId, user); // Initialize if new

  if (!user.subscribed && user.triesUsed >= FREE_TRIES) {
    return res.status(402).json({ error: "Limit reached. Please subscribe." });
  }
  
  req.userId = userId;
  next();
};

/* ===================== ROUTES ===================== */

app.post("/subscribe", async (req, res) => {
  try {
    const { plan, userId } = req.body;
    const priceId = PRICE_IDS[plan];

    if (!priceId) return res.status(400).json({ error: "Invalid plan" });

    const session = await stripe.checkout.sessions.create({
      mode: "subscription", // Changed to subscription for monthly/yearly logic
      payment_method_types: ["card"],
      line_items: [{ price: priceId, quantity: 1 }],
      success_url: `${process.env.FRONTEND_URL}/success`,
      cancel_url: `${process.env.FRONTEND_URL}/cancel`,
      metadata: { userId }
    });

    res.json({ checkoutUrl: session.url });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post("/start", checkAccess, async (req, res) => {
  try {
    const { dish } = req.body;
    const state = { dish, step: 0, errors: [] };
    
    // Improved Cache Key (Dish + Skill)
    const cacheKey = `${dish}-step-0`;
    
    let output;
    if (stepCache.has(cacheKey)) {
      output = stepCache.get(cacheKey);
    } else {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini", // Corrected model name
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: stepPrompt(state) }
        ]
      });
      output = completion.choices[0].message.content;
      stepCache.set(cacheKey, output);
    }

    const user = users.get(req.userId);
    if (!user.subscribed) user.triesUsed++;

    res.json({ state, response: output });
  } catch (e) {
    res.status(500).json({ error: "AI Service Unavailable" });
  }
});

app.post("/next", checkAccess, async (req, res) => {
  try {
    let { state } = req.body;
    state.step++;
    
    const cacheKey = `${state.dish}-step-${state.step}`;

    let output;
    if (stepCache.has(cacheKey)) {
      output = stepCache.get(cacheKey);
    } else {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: stepPrompt(state) }
        ]
      });
      output = completion.choices[0].message.content;
      stepCache.set(cacheKey, output);
    }

    const user = users.get(req.userId);
    if (!user.subscribed) user.triesUsed++;

    res.json({ state, response: output });
  } catch (e) {
    res.status(500).json({ error: "Failed to fetch next step" });
  }
});

/* ===================== SERVER ===================== */

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üç≥ Cooking Copilot active on port ${PORT}`);
});
